<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sand Tetris</title>
  <style>
    :root {
      --sand-1: #f4e7c2;
      --sand-2: #ecd9ad;
      --sand-3: #e5cf9b;
      --sand-4: #d9c287;
      --line: #c5b06f;
      --bg: #f7eed2;
      --accent: #a3843a;
      --text: #5a4e2c;
    }

    html, body {
      height: 100%;
      margin: 0;
      background: linear-gradient(180deg, var(--bg) 0%, #efe4be 60%, #e5d5a4 100%);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      color: var(--text);
    }

    .wrap {
      display: grid;
      grid-template-columns: auto 1fr;
      gap: 24px;
      max-width: 960px;
      margin: 24px auto;
      padding: 16px 20px;
      align-items: start;
    }

    .panel {
      background: rgba(255, 255, 255, 0.65);
      backdrop-filter: blur(2px);
      border: 1px solid rgba(0,0,0,0.06);
      border-radius: 10px;
      padding: 14px 16px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.08);
    }

    h1 {
      margin: 0 0 8px;
      font-size: 22px;
      letter-spacing: 0.3px;
    }

    .meta {
      font-size: 13px;
      line-height: 1.5;
      opacity: 0.9;
    }

    .stats {
      margin-top: 12px;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px 14px;
      font-size: 14px;
    }

    .stat-label { opacity: 0.7; }
    .stat-value { font-weight: 600; }

    .next-wrap {
      margin-top: 10px;
      display: grid;
      gap: 8px;
    }

    .keys {
      margin-top: 10px;
      font-size: 13px;
      line-height: 1.6;
      opacity: 0.95;
    }

    canvas {
      image-rendering: pixelated; /* crisp blocks */
      border-radius: 10px;
      border: 1px solid rgba(0,0,0,0.08);
      background: transparent;
      box-shadow: inset 0 2px 8px rgba(0,0,0,0.06), 0 8px 20px rgba(0,0,0,0.06);
    }

    .footer {
      text-align: center;
      font-size: 12px;
      opacity: 0.7;
      margin-top: 8px;
    }

    /* Overlay UI for menu and level complete */
    .overlay {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.12);
      z-index: 10;
    }
    .overlay-inner {
      background: rgba(255, 255, 255, 0.85);
      backdrop-filter: blur(2px);
      border: 1px solid rgba(0,0,0,0.08);
      border-radius: 12px;
      padding: 18px 20px;
      min-width: 280px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.12);
      color: var(--text);
    }
    .overlay h2 { margin: 0 0 8px; font-size: 20px; }
    .overlay p { margin: 8px 0; font-size: 14px; opacity: 0.9; }
    .overlay .row { display: flex; gap: 10px; align-items: center; }
    .btn {
      display: inline-block;
      padding: 8px 12px;
      border-radius: 8px;
      border: 1px solid rgba(0,0,0,0.1);
      background: #f0e7c9;
      color: #4b4125;
      font-weight: 600;
      cursor: pointer;
    }
    .btn:hover { filter: brightness(0.98); }
  </style>
  <link rel="icon" href="data:,">
  <meta name="color-scheme" content="light">
  <meta name="description" content="A tiny sand-themed Tetris in one file">
  <meta name="theme-color" content="#e7d9a8">
</head>
<body>
  <div class="wrap">
    <div class="panel" style="width: 220px;">
      <h1>Sand Tetris</h1>
      <div class="meta">
        Stack shapes of sand. Clear full rows to score. The wind waits for no block.
      </div>
      <div class="stats">
        <div class="stat-label">Level</div><div id="level" class="stat-value">1</div>
        <div class="stat-label">Goals</div>
        <div id="goals" class="stat-value" style="grid-column: span 1;">
          <div class="goal-item">—</div>
        </div>
      </div>
      <div class="next-wrap">
        <div class="stat-label">Next</div>
        <canvas id="next" width="120" height="120"></canvas>
      </div>
      <div class="keys">
        <div><strong>← / →</strong>: Move</div>
        <div><strong>↑ / Z / X</strong>: Rotate</div>
        <div><strong>↓</strong>: Soft drop</div>
        <div><strong>Space</strong>: Hard drop</div>
        <div><strong>Esc</strong>: Pause</div>
        <div><strong>R</strong>: Restart</div>
        <div><strong>I</strong>: Info / Rules</div>
      </div>
      <div class="footer">Made of pixels and sand.</div>
    </div>

    <canvas id="game" width="300" height="600" class="panel"></canvas>
    <div id="overlay" class="overlay">
      <div class="overlay-inner">
        <h2 id="overlay-title">Sand Tetris</h2>
        <p id="overlay-desc">Stack shapes of sand. Meet the goals to advance.</p>
        <div id="overlay-goals" style="font-size: 14px; margin-top: 6px;"></div>
        <p id="overlay-progress">Levels beaten: <strong id="levels-beaten">0</strong></p>
        <div class="row" style="margin-top: 10px;">
          <button id="btn-play" class="btn">Play</button>
          <button id="btn-reset" class="btn" title="Reset progress">Reset</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Config
    const COLS = 10;
    const ROWS = 20;
    const CELL = 30; // 10 x 20 grid => 300x600 canvas

    const DROP_BASE_MS = 900; // base drop interval
    const SPEED_PER_STAGE = 0.92; // gentle speed-up per level
    // Vibrant, high-contrast palette
    const COLORS = ['#ff5d57', '#ffd166', '#06d6a0', '#118ab2', '#8338ec', '#ef476f'];
    const COLOR_NAMES = ['Rose', 'Amber', 'Mint', 'Azure', 'Violet', 'Coral'];

    // Shapes (tetrominoes)
    const SHAPES = {
      I: [[1,1,1,1]],
      J: [[1,0,0],[1,1,1]],
      L: [[0,0,1],[1,1,1]],
      O: [[1,1],[1,1]],
      S: [[0,1,1],[1,1,0]],
      T: [[0,1,0],[1,1,1]],
      Z: [[1,1,0],[0,1,1]],
    };

    const SHAPE_KEYS = Object.keys(SHAPES);

    // Canvas
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const nextCanvas = document.getElementById('next');
    const nctx = nextCanvas.getContext('2d');
    const overlayEl = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlay-title');
    const overlayDesc = document.getElementById('overlay-desc');
    const overlayProgress = document.getElementById('levels-beaten');
    const btnPlay = document.getElementById('btn-play');
    const btnReset = document.getElementById('btn-reset');

    // UI
    // Removed Score/Lines from HUD in favor of goals with progress
    const levelEl = document.getElementById('level');
    const goalsEl = document.getElementById('goals');

    // Sand pattern generator
    function makeSandPattern(base = '#ecd9ad') {
      const c = document.createElement('canvas');
      c.width = 24; c.height = 24;
      const x = c.getContext('2d');
      // Base
      x.fillStyle = base;
      x.fillRect(0,0,c.width,c.height);
      // Speckles
      for (let i = 0; i < 140; i++) {
        const px = Math.random() * c.width;
        const py = Math.random() * c.height;
        const shade = Math.random() < 0.6 ? '#d9c287' : '#f4e7c2';
        x.fillStyle = shade;
        x.globalAlpha = 0.15 + Math.random() * 0.2;
        x.fillRect(px, py, 1, 1);
      }
      x.globalAlpha = 1;
      return ctx.createPattern(c, 'repeat');
    }

    const sandPattern = makeSandPattern();

    // Board
    function makeBoard() {
      return Array.from({ length: ROWS }, () => Array(COLS).fill(0));
    }
    let board = makeBoard();

    // Piece factory
    function rotate(shape) {
      const h = shape.length, w = shape[0].length;
      const res = Array.from({ length: w }, () => Array(h).fill(0));
      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          res[x][h - 1 - y] = shape[y][x];
        }
      }
      return res;
    }
    function rotateAny(mat) {
      const h = mat.length, w = mat[0].length;
      const res = Array.from({ length: w }, () => Array(h).fill(0));
      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          res[x][h - 1 - y] = mat[y][x];
        }
      }
      return res;
    }

    function clone(m) { return m.map(row => row.slice()); }

    class Bag {
      constructor() { this.bag = []; }
      next() {
        if (this.bag.length === 0) {
          this.bag = SHAPE_KEYS.slice();
          // shuffle
          for (let i = this.bag.length - 1; i > 0; i--) {
            const j = (Math.random() * (i+1))|0;
            [this.bag[i], this.bag[j]] = [this.bag[j], this.bag[i]];
          }
        }
        return this.bag.pop();
      }
    }
    const bag = new Bag();

    function spawnPiece() {
      const key = bag.next();
      const shape = clone(SHAPES[key]);
      // assign random color index (1..COLORS.length) per filled cell
      const colors = shape.map(row => row.map(v => v ? (1 + (Math.random() * COLORS.length | 0)) : 0));
      const piece = {
        key,
        shape,
        colors,
        x: Math.floor((COLS - shape[0].length) / 2),
        y: 0,
      };
      return piece;
    }

    let current = null;
    let nextPiece = null;

    // Game state
    let score = 0;
    let lines = 0;
    let stage = 1; // 1-based visible stage number
    let dropInterval = DROP_BASE_MS;
    let dropAccumulator = 0;
    let paused = false;
    let gameOver = false;
    let resolving = false; // animating clears
    let pendingNextPiece = null; // spawn after clears
    let clearing = null; // { cells: Set<'x,y'>, lineRows: number[], endTime: number }
    let clearFade = 0; // 0..1 fade progress for clearing
    let animToken = 0; // invalidates pending animations on restart
    let inMenu = true;
    let inInfo = false;
    let levelComplete = false;
    let levelsBeaten = 0;

    // Per-level progress
    let levelScore = 0;
    let levelLines = 0;
    let levelColorCounts = Array(COLORS.length + 1).fill(0); // index by colorIndex
    let levelClusterBlocks = 0; // blocks cleared via 5+ clusters
    let currentGoals = []; // array of { type: 'lines'|'score'|'color'|'cluster', target: n, color?: idx }

    function updateHUD() {
      levelEl.textContent = stage;
      // Render goals with progress counters
      goalsEl.innerHTML = '';
      if (!currentGoals || currentGoals.length === 0) {
        goalsEl.innerHTML = '<div class="goal-item">—</div>';
      } else {
        for (const g of currentGoals) {
          const prog = getGoalProgress(g);
          const total = g.target;
          const label = goalToText(g);
          const done = prog >= total;
          const row = document.createElement('div');
          row.className = 'goal-item';
          row.style.opacity = done ? '0.6' : '1';
          if (g.type === 'color') {
            const sw = `<span style="display:inline-block;width:10px;height:10px;border-radius:2px;vertical-align:middle;margin-right:6px;background:${COLORS[g.color-1]};border:1px solid rgba(0,0,0,0.2);"></span>`;
            row.innerHTML = `${sw}${label}: <strong>${Math.min(prog,total)}/${total}</strong>`;
          } else {
            row.innerHTML = `${label}: <strong>${Math.min(prog,total)}/${total}</strong>`;
          }
          goalsEl.appendChild(row);
        }
      }
    }

    function goalToText(goal) {
      switch (goal.type) {
        case 'lines': return `Clear ${goal.target} lines`;
        case 'score': return `Score ${goal.target}`;
        case 'color': {
          const name = COLOR_NAMES[goal.color-1] || 'Color';
          return `Remove ${goal.target} ${name}`;
        }
        case 'cluster': return `Clear ${goal.target} cluster blocks`;
      }
      return '—';
    }

    function getGoalProgress(goal) {
      switch (goal.type) {
        case 'lines': return levelLines;
        case 'score': return levelScore;
        case 'color': return levelColorCounts[goal.color] || 0;
        case 'cluster': return levelClusterBlocks;
      }
      return 0;
    }

    // Collision
    function collides(piece, ox = 0, oy = 0, testShape = null) {
      const shape = testShape || piece.shape;
      for (let y = 0; y < shape.length; y++) {
        for (let x = 0; x < shape[y].length; x++) {
          if (!shape[y][x]) continue;
          const nx = piece.x + x + ox;
          const ny = piece.y + y + oy;
          if (ny < 0) continue; // allow above top
          if (nx < 0 || nx >= COLS || ny >= ROWS) return true;
          if (board[ny][nx]) return true;
        }
      }
      return false;
    }

    // Merge piece into board
    function merge(piece) {
      for (let y = 0; y < piece.shape.length; y++) {
        for (let x = 0; x < piece.shape[y].length; x++) {
          if (!piece.shape[y][x]) continue;
          const nx = piece.x + x;
          const ny = piece.y + y;
          if (ny >= 0) board[ny][nx] = piece.colors[y][x];
        }
      }
    }

    // Gravity for line clears only: shift intact rows down, preserve gaps
    function applyLineClearGravity(lineRows) {
      if (!lineRows || lineRows.length === 0) return;
      const cleared = new Set(lineRows);
      let write = ROWS - 1;
      for (let y = ROWS - 1; y >= 0; y--) {
        if (!cleared.has(y)) {
          if (write !== y) {
            board[write] = board[y].slice();
          }
          write--;
        }
      }
      // Fill the remaining rows at the top with zeros
      for (let y = write; y >= 0; y--) {
        board[y] = Array(COLS).fill(0);
      }
    }

    // Detect clears without mutating
    function getFullLineRows() {
      const rows = [];
      for (let y = 0; y < ROWS; y++) if (board[y].every(v => v)) rows.push(y);
      return rows;
    }

    function findColorGroupCells() {
      const seen = Array.from({ length: ROWS }, () => Array(COLS).fill(false));
      const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
      const cells = [];
      for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLS; x++) {
          const color = board[y][x];
          if (!color || seen[y][x]) continue;
          const stack = [[x,y]];
          const comp = [];
          seen[y][x] = true;
          while (stack.length) {
            const [cx, cy] = stack.pop();
            comp.push([cx, cy]);
            for (const [dx, dy] of dirs) {
              const nx = cx + dx, ny = cy + dy;
              if (nx>=0 && nx<COLS && ny>=0 && ny<ROWS && !seen[ny][nx] && board[ny][nx] === color) {
                seen[ny][nx] = true;
                stack.push([nx, ny]);
              }
            }
          }
          if (comp.length >= 5) for (const c of comp) cells.push(c);
        }
      }
      return cells; // array of [x,y]
    }

    function computeClears() {
      const lineRows = getFullLineRows();
      const colorCells = findColorGroupCells();
      if (lineRows.length === 0 && colorCells.length === 0) return null;
      const cells = new Set();
      for (const y of lineRows) for (let x = 0; x < COLS; x++) cells.add(`${x},${y}`);
      for (const [x,y] of colorCells) cells.add(`${x},${y}`);
      const clusterSet = new Set(colorCells.map(([x,y]) => `${x},${y}`));
      return { cells, lineRows, clusterSet };
    }

    function resolveStep() {
      const clears = computeClears();
      if (!clears) {
        resolving = false;
        clearing = null;
        clearFade = 0;
        if (!levelComplete && pendingNextPiece) {
          current = pendingNextPiece;
          pendingNextPiece = null;
          if (collides(current, 0, 0)) { gameOver = true; paused = true; showGameOver(); }
        }
        return;
      }
      const token = animToken;
      // Keep full line rows array so we can apply row-based gravity only for lines
      clearing = { cells: clears.cells, lineRows: clears.lineRows, clusterSet: clears.clusterSet, endTime: performance.now() + 500 };
      setTimeout(() => {
        if (token !== animToken) return; // aborted
        let removed = 0;
        let removedCluster = 0;
        const removedByColor = Array(COLORS.length + 1).fill(0);
        for (const key of clearing.cells) {
          const [sx, sy] = key.split(',').map(Number);
          const val = board[sy][sx];
          if (val) {
            removed++;
            removedByColor[val]++;
            if (clearing.clusterSet && clearing.clusterSet.has(key)) removedCluster++;
            board[sy][sx] = 0;
          }
        }
        score += removed;
        lines += clearing.lineRows.length;
        // Level-local tallies
        levelScore += removed;
        levelLines += clearing.lineRows.length;
        for (let i = 1; i < removedByColor.length; i++) levelColorCounts[i] += removedByColor[i];
        levelClusterBlocks += removedCluster;
        updateHUD();
        // Only apply gravity for line clears. Cluster clears leave gaps.
        applyLineClearGravity(clearing.lineRows);
        clearing = null;
        clearFade = 0;
        // Check for goal completion before continuing chain/spawn
        if (checkGoalComplete()) {
          onLevelComplete();
          return;
        }
        setTimeout(() => { if (token === animToken) resolveStep(); }, 20);
      }, 500);
    }

    // Rotation with wall kicks (simple)
    function tryRotate(dir = 1) {
      const rotShape = rotate(current.shape);
      const rotColors = rotateAny(current.colors);
      // For counter-rotate, rotate 3 times
      const shape = dir === 1 ? rotShape : rotate(rotate(rotate(current.shape)));
      const colors = dir === 1 ? rotColors : rotateAny(rotateAny(rotateAny(current.colors)));
      const kicks = [0, -1, 1, -2, 2];
      for (const k of kicks) {
        if (!collides(current, k, 0, shape)) {
          current.shape = shape;
          current.colors = colors;
          current.x += k;
          return true;
        }
      }
      return false;
    }

    // Draw helpers
    function drawCellAt(g, px, py, size, colorIndex, tintAlpha = 0.7) {
      // Base sand fill
      g.fillStyle = sandPattern;
      g.fillRect(px, py, size, size);
      // Subtle bevel
      g.fillStyle = 'rgba(255,255,255,0.35)';
      g.fillRect(px+1, py+1, size-2, 4);
      g.fillStyle = 'rgba(0,0,0,0.12)';
      g.fillRect(px+1, py+size-4, size-2, 3);
      // Edge
      g.strokeStyle = 'rgba(0,0,0,0.30)';
      g.lineWidth = 1.2;
      g.strokeRect(px+0.5, py+0.5, size-1, size-1);
      // Soft shadow
      g.fillStyle = 'rgba(0,0,0,0.06)';
      g.fillRect(px+2, py+size-2, size-4, 2);
      // Color tint overlay
      if (colorIndex) {
        g.save();
        g.globalAlpha = tintAlpha;
        g.fillStyle = COLORS[colorIndex - 1];
        g.fillRect(px, py, size, size);
        g.restore();
      }
    }

    function drawCell(g, x, y, size, colorIndex, overallAlpha = 1, tintAlpha = 0.7) {
      const px = x * size;
      const py = y * size;
      g.save();
      g.globalAlpha = overallAlpha;
      drawCellAt(g, px, py, size, colorIndex, tintAlpha);
      g.restore();
    }

    function drawBackground() {
      // Gradient sky/sand
      const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
      grad.addColorStop(0, '#f8f0d8');
      grad.addColorStop(0.6, '#efe4be');
      grad.addColorStop(1, '#e6d6a6');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      // Lighten playfield slightly for contrast
      ctx.fillStyle = 'rgba(255,255,255,0.22)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Dunes (soft curves)
      ctx.fillStyle = 'rgba(211, 191, 133, 0.12)';
      drawDune(0.3, 18);
      ctx.fillStyle = 'rgba(190, 167, 100, 0.10)';
      drawDune(0.6, 12);
      function drawDune(freq, height) {
        ctx.beginPath();
        ctx.moveTo(0, canvas.height);
        for (let x = 0; x <= canvas.width; x++) {
          const t = x / canvas.width;
          const y = canvas.height - (Math.sin(t * Math.PI * 2 * freq) * 0.5 + 0.5) * height - 12;
          ctx.lineTo(x, y);
        }
        ctx.lineTo(canvas.width, canvas.height);
        ctx.closePath();
        ctx.fill();
      }

      // Subtle grid lines
      ctx.strokeStyle = 'rgba(0,0,0,0.05)';
      ctx.lineWidth = 1;
      for (let x = 1; x < COLS; x++) {
        ctx.beginPath();
        ctx.moveTo(x * CELL + 0.5, 0);
        ctx.lineTo(x * CELL + 0.5, canvas.height);
        ctx.stroke();
      }
      for (let y = 1; y < ROWS; y++) {
        ctx.beginPath();
        ctx.moveTo(0, y * CELL + 0.5);
        ctx.lineTo(canvas.width, y * CELL + 0.5);
        ctx.stroke();
      }
    }

    function drawBoard() {
      for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLS; x++) {
          const c = board[y][x];
          if (c) {
            let alpha = 1;
            if (clearing && clearing.cells && clearing.cells.has(`${x},${y}`)) {
              alpha = 1 - clearFade; // fade out over time
            }
            drawCell(ctx, x, y, CELL, c, alpha, 0.4);
          }
        }
      }
    }

    function drawPiece(g, piece, size, opts = {}) {
      const overallAlpha = opts.overallAlpha ?? 1;
      const tintAlpha = opts.tintAlpha ?? 0.4;
      for (let y = 0; y < piece.shape.length; y++) {
        for (let x = 0; x < piece.shape[y].length; x++) {
          if (!piece.shape[y][x]) continue;
          const gx = piece.x + x;
          const gy = piece.y + y;
          const colorIndex = piece.colors[y][x];
          if (gy >= 0) drawCell(g, gx, gy, size, colorIndex, overallAlpha, tintAlpha);
        }
      }
    }

    function drawGhost() {
      // Drop ghost piece preview
      const ghost = { x: current.x, y: current.y, shape: current.shape, colors: current.colors };
      while (!collides(ghost, 0, 1)) ghost.y++;
      // Very light projection
      drawPiece(ctx, ghost, CELL, { overallAlpha: 0.22, tintAlpha: 0.1 });
    }

    function drawNext() {
      nctx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
      nctx.fillStyle = 'rgba(255,255,255,0.65)';
      nctx.fillRect(0,0,nextCanvas.width,nextCanvas.height);
      if (!nextPiece) return;
      const s = nextPiece.shape;
      const size = 24;
      // Centering
      const w = s[0].length * size;
      const h = s.length * size;
      const ox = Math.floor((nextCanvas.width - w) / 2);
      const oy = Math.floor((nextCanvas.height - h) / 2);
      nctx.save();
      nctx.translate(ox, oy);
      // draw using sand cell logic but adapted
      for (let y = 0; y < s.length; y++) {
        for (let x = 0; x < s[y].length; x++) {
          if (!s[y][x]) continue;
          // local cell renderer
          const px = x * size;
          const py = y * size;
          const colorIndex = nextPiece.colors[y][x];
          drawCellAt(nctx, px, py, size, colorIndex);
        }
      }
      nctx.restore();
    }

    // Game loop
    let last = 0;
    function loop(ts) {
      const dt = Math.min(32, ts - last);
      last = ts;
      if (!paused && !gameOver && !resolving) {
        dropAccumulator += dt;
        if (dropAccumulator >= dropInterval) {
          dropAccumulator = 0;
          tick();
        }
      }
      render();
      requestAnimationFrame(loop);
    }

    function tick() {
      if (!collides(current, 0, 1)) {
        current.y++;
      } else {
        // Lock piece and start animated clear cascade
        merge(current);
        pendingNextPiece = nextPiece;
        nextPiece = spawnPiece();
        current = null; // hide piece during resolution
        resolving = true;
        resolveStep();
      }
    }

    function showGameOver() {
      ctx.save();
      ctx.globalAlpha = 0.85;
      ctx.fillStyle = '#f7f0d4';
      ctx.fillRect(20, canvas.height/2 - 80, canvas.width-40, 160);
      ctx.globalAlpha = 1;
      ctx.strokeStyle = 'rgba(0,0,0,0.15)';
      ctx.strokeRect(20.5, canvas.height/2 - 79.5, canvas.width-41, 159);
      ctx.fillStyle = '#5a4e2c';
      ctx.textAlign = 'center';
      ctx.font = 'bold 22px system-ui, sans-serif';
      ctx.fillText('Game Over', canvas.width/2, canvas.height/2 - 24);
      ctx.font = '14px system-ui, sans-serif';
      ctx.fillText('Score: ' + score, canvas.width/2, canvas.height/2 + -2);
      ctx.fillText('Press R to restart', canvas.width/2, canvas.height/2 + 20);
      ctx.restore();
    }

    function showPaused() {
      ctx.save();
      ctx.globalAlpha = 0.85;
      ctx.fillStyle = '#f7f0d4';
      ctx.fillRect(40, 24, canvas.width - 80, 44);
      ctx.globalAlpha = 1;
      ctx.strokeStyle = 'rgba(0,0,0,0.15)';
      ctx.strokeRect(40.5, 24.5, canvas.width-81, 43);
      ctx.fillStyle = '#5a4e2c';
      ctx.textAlign = 'center';
      ctx.font = 'bold 18px system-ui, sans-serif';
      ctx.fillText('Paused — Esc to resume', canvas.width/2, 52);
      ctx.restore();
    }

    function render() {
      // Update clear fade progress for animation
      if (clearing && clearing.endTime) {
        const remain = Math.max(0, clearing.endTime - performance.now());
        clearFade = Math.min(1, 1 - (remain / 500));
      } else {
        clearFade = 0;
      }
      drawBackground();
      if (current && !resolving) drawGhost();
      drawBoard();
      if (current) drawPiece(ctx, current, CELL);
      drawNext();
      if (paused && !gameOver && !inMenu && !levelComplete) showPaused();
      if (gameOver) showGameOver();
    }

    // Input
    let heldDown = false; // to accelerate soft drop
    document.addEventListener('keydown', (e) => {
      if (gameOver && e.key.toLowerCase() === 'r') { restart(); return; }
      if (inMenu || levelComplete) return;
      // Info toggle
      if (e.key.toLowerCase() === 'i') {
        if (inInfo) { hideOverlay(); inInfo = false; paused = false; } else { showInfoOverlay(); }
        return;
      }
      // Pause toggle on Escape
      if (e.key === 'Escape') {
        if (inInfo) { hideOverlay(); inInfo = false; paused = false; } else { paused = !paused; }
        return;
      }
      if (paused || resolving || !current) return;
      switch (e.key) {
        case 'ArrowLeft':
          if (!collides(current, -1, 0)) current.x--;
          break;
        case 'ArrowRight':
          if (!collides(current, 1, 0)) current.x++;
          break;
        case 'ArrowDown':
          heldDown = true;
          if (!collides(current, 0, 1)) current.y++;
          break;
        case ' ': // hard drop
          e.preventDefault();
          while (!collides(current, 0, 1)) { current.y++; }
          merge(current);
          pendingNextPiece = nextPiece;
          nextPiece = spawnPiece();
          current = null;
          resolving = true;
          resolveStep();
          break;
        case 'ArrowUp':
        case 'x':
        case 'X':
          tryRotate(1);
          break;
        case 'z':
        case 'Z':
          tryRotate(-1);
          break;
        case 'r':
        case 'R':
          restart();
          break;
      }
    });

    document.addEventListener('keyup', (e) => {
      if (e.key === 'ArrowDown') heldDown = false;
    });

    // Restart
    function restart() { // restart current level
      startLevel(stage - 1);
    }

    // ---- Levels & Menu ----
    function loadProgress() {
      const v = localStorage.getItem('sand_levels_beaten');
      levelsBeaten = v ? Math.max(0, parseInt(v, 10) || 0) : 0;
    }
    function saveProgress() {
      localStorage.setItem('sand_levels_beaten', String(levelsBeaten));
    }

    function getLevelConfig(idx0) { return buildLevelConfig(idx0); }
    function previewLevelConfig(idx0) { return buildLevelConfig(idx0); }
    function buildLevelConfig(idx0) { // deterministic per level
      const speed = Math.max(120, DROP_BASE_MS * Math.pow(SPEED_PER_STAGE, idx0));
      const startRows = Math.min(12, Math.floor(idx0 / 2));
      const density = Math.min(0.6, 0.25 + idx0 * 0.02);

      // Deterministic goal count by bands, gradually increasing complexity
      let goalCount = 1;
      if (idx0 >= 3 && idx0 < 8) goalCount = (idx0 % 3 === 0) ? 2 : 1;
      else if (idx0 >= 8 && idx0 < 16) goalCount = (idx0 % 4 === 1) ? 1 : 2;
      else if (idx0 >= 16 && idx0 < 28) goalCount = (idx0 % 5 === 0) ? 3 : 2;
      else if (idx0 >= 28) goalCount = 2 + ((idx0 % 5 === 0) ? 1 : 0) + ((idx0 % 11 === 0) ? 1 : 0);
      goalCount = Math.min(4, Math.max(1, goalCount));

      // Build deterministic set of goal types: prefer frequent 'cluster' goals
      const types = [];
      if (idx0 === 0) { goalCount = 1; types.push('lines'); }
      else if (idx0 === 1) { goalCount = 1; types.push('cluster'); }
      else if (idx0 === 2) { goalCount = 1; types.push('score'); }
      else {
        if (idx0 % 2 === 0) types.push('lines');
        if (idx0 % 3 === 0 || goalCount >= 3) types.push('score');
        while (types.length < goalCount) {
          const haveCluster = types.filter(t => t === 'cluster').length;
          const haveColor = types.filter(t => t === 'color').length;
          // Bias towards cluster more often than color
          types.push(haveCluster <= haveColor + 1 ? 'cluster' : 'color');
        }
      }

      // Deterministic targets and colors
      const goals = [];
      let colorCursor = (idx0 * 3 + 1) % COLORS.length; // start position
      let extraColorGoals = 0;
      for (const t of types) {
        if (t === 'lines') {
          const base = 2 + Math.floor(idx0 / 3);
          const adjust = (idx0 % 2);
          goals.push({ type: 'lines', target: Math.min(12, base + adjust) });
        } else if (t === 'score') {
          const base = 50 + idx0 * 22;
          const adjust = (idx0 % 7) * 2;
          goals.push({ type: 'score', target: base + adjust });
        } else if (t === 'color') {
          const color = 1 + colorCursor;
          colorCursor = (colorCursor + 2) % COLORS.length; // spread colors deterministically
          const base = 10 + Math.floor(idx0 * 1.4) + (extraColorGoals * 4);
          const adjust = (idx0 % 3);
          goals.push({ type: 'color', color, target: base + adjust });
          extraColorGoals++;
        } else if (t === 'cluster') {
          const base = 16 + Math.floor(idx0 * 2.2);
          const adjust = (idx0 % 5) * 2;
          goals.push({ type: 'cluster', target: base + adjust });
        }
      }

      return { dropMs: speed, startRows, density, goals };
    }

    function seedStartingRows(rows, density) {
      // Clear board
      board = makeBoard();
      if (rows <= 0) return;
      const startY = ROWS - rows;
      // Fill with random occupancy avoiding full lines
      for (let y = startY; y < ROWS; y++) {
        let filledCount = 0;
        for (let x = 0; x < COLS; x++) {
          if (Math.random() < density) {
            const color = 1 + (Math.random() * COLORS.length | 0);
            board[y][x] = color; filledCount++;
          }
        }
        if (filledCount === COLS) {
          const rx = (Math.random() * COLS) | 0; // knock one out
          board[y][rx] = 0;
        }
      }
      // Break any accidental clusters >=5 by random thinning/recolor
      let safety = 0;
      while (true && safety < 200) {
        safety++;
        const groups = findColorGroupCells();
        if (groups.length === 0) break;
        // Recolor a random cell from each group to a different color or empty
        for (let i = 0; i < groups.length; i++) {
          const [gx, gy] = groups[i];
          if (gy < startY) continue; // only adjust seeded area
          if (Math.random() < 0.5) {
            board[gy][gx] = 0;
          } else {
            const old = board[gy][gx];
            let nc = old;
            for (let tries = 0; tries < 4 && nc === old; tries++) nc = 1 + ((Math.random() * COLORS.length) | 0);
            board[gy][gx] = nc;
          }
        }
      }
      // Ensure seeded rows are not full lines
      for (let y = startY; y < ROWS; y++) {
        if (board[y].every(v => v)) {
          const rx = (Math.random() * COLS) | 0;
          board[y][rx] = 0;
        }
      }
    }

    function checkGoalComplete() {
      if (!currentGoals || currentGoals.length === 0) return false;
      return currentGoals.every(g => getGoalProgress(g) >= g.target);
    }

    function onLevelComplete() {
      levelComplete = true;
      paused = true;
      // Progression: only increment if this is the next unbeaten level
      const currentIdx0 = stage - 1;
      if (levelsBeaten === currentIdx0) { levelsBeaten++; saveProgress(); }
      showLevelCompleteOverlay();
    }

    function startLevel(idx0) {
      // Reset per-level state
      levelScore = 0; levelLines = 0; levelColorCounts = Array(COLORS.length + 1).fill(0); levelClusterBlocks = 0;
      levelComplete = false; gameOver = false; paused = false; resolving = false; inMenu = false; inInfo = false;
      pendingNextPiece = null; clearing = null; clearFade = 0; animToken++;
      dropAccumulator = 0; last = 0;
      stage = idx0 + 1;
      const cfg = getLevelConfig(idx0);
      dropInterval = cfg.dropMs;
      currentGoals = cfg.goals;
      seedStartingRows(cfg.startRows, cfg.density);
      // Prepare pieces
      current = spawnPiece();
      nextPiece = spawnPiece();
      updateHUD();
      hideOverlay();
      render();
    }

    function showMenuOverlay() {
      overlayTitle.textContent = 'Sand Tetris';
      overlayDesc.textContent = 'Next goals:';
      overlayProgress.textContent = String(levelsBeaten);
      btnPlay.textContent = 'Play';
      // Preview goals for next level
      const nextIdx0 = levelsBeaten;
      const preview = previewLevelConfig(nextIdx0);
      renderOverlayGoals(preview.goals);
      overlayEl.style.display = 'flex';
      inMenu = true; paused = true;
    }

    function showInfoOverlay() {
      const elGoals = document.getElementById('overlay-goals');
      elGoals.innerHTML = '';
      overlayTitle.textContent = 'How to Play';
      overlayDesc.innerHTML = [
        'Stack falling shapes. Clear full rows to score.',
        'Clear groups of 5+ connected same-color blocks to earn extra “cluster” clears.',
        'Finish all goals on the left to advance.'
      ].map(t => `<div style="margin:4px 0;">• ${t}</div>`).join('');
      overlayProgress.textContent = String(levelsBeaten);
      btnPlay.textContent = 'Resume';
      overlayEl.style.display = 'flex';
      inInfo = true; paused = true;
    }

    function renderOverlayGoals(goals) {
      const el = document.getElementById('overlay-goals');
      el.innerHTML = '';
      for (const g of goals) {
        const div = document.createElement('div');
        if (g.type === 'color') {
          const sw = `<span style="display:inline-block;width:10px;height:10px;border-radius:2px;vertical-align:middle;margin-right:6px;background:${COLORS[g.color-1]};border:1px solid rgba(0,0,0,0.2);"></span>`;
          div.innerHTML = `${sw}${goalToText(g)}`;
        } else {
          div.textContent = goalToText(g);
        }
        el.appendChild(div);
      }
    }
    function showLevelCompleteOverlay() {
      overlayTitle.textContent = 'Level Complete!';
      const nextIdx0 = (stage - 1) + 1;
      const nextCfg = previewLevelConfig(nextIdx0);
      overlayDesc.textContent = 'Next goals:';
      renderOverlayGoals(nextCfg.goals);
      overlayProgress.textContent = String(levelsBeaten);
      btnPlay.textContent = 'Play Next';
      overlayEl.style.display = 'flex';
    }
    function hideOverlay() { overlayEl.style.display = 'none'; }

    // Overlay actions
    btnPlay.addEventListener('click', () => {
      if (inInfo) {
        hideOverlay(); inInfo = false; paused = false; return;
      }
      if (levelComplete || inMenu) {
        const nextIdx0 = levelComplete ? (stage - 1) + 1 : levelsBeaten;
        startLevel(nextIdx0);
      }
    });
    btnReset.addEventListener('click', () => {
      if (!confirm('Reset progress?')) return;
      levelsBeaten = 0; saveProgress();
      showMenuOverlay();
    });

    // Start
    loadProgress();
    updateHUD();
    render();
    showMenuOverlay();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
